A
1211
2122
2113
1132
2144

for (int i=1; i<=5; i++){
    max = A[i][1];
    k[i] = 1; //массив кол-ва max эл-ов в строке
    x = 1; //дл€ нового массива строка
    Mas[i][x] = 1; //массив дл€ записи индексов максимумов
    for (j = 1; j<=4; j++) {
	if (A[i][j] > max){
	   max = A[i][j];
	   k[i] = 1; // становитс€ единичкой при каждом новом max
	   x = 1;// если будет находить новый макс, то запись в новый массив с 1-эл-а
	   Mas[i][x] = j;}
	if (A[i][j] == max){
	    k[i]++;
	    x++; // next
	    Mas[i][x] = j;	    
	   }
}



//нашел две матрицы : из них нужно сделать общую третью
int k_count = 1; //всего мотивов

for (int i=1; i<=5; i++) {
    k_count = k[i]*k_count;  //всего мотивов

h = 1;// (сегменты)
k[0] = 1;// заполн€ем 1, т.к. изначально он равен не известно чему
int Masiv[5][k_count];

// после нахождени всего мотивов 
for ( i=1; i<=5 ;i++){
    k_count = k_count/k[i]; // делим на опред кол-во дл€ вставки в эту //область наших символов(сегменты)
//посто€нно делим, т.к. сегменты в размере уменьшаютс€
     
    y = 1;// элемент с которого начинаетс€ сегмент заполнени€ данных [i]
//нужно реализовать повтор сегментов
// и ограничить заполн€емость (хот€, не об€зательно)//или об€зательно
    h = h * k[i-1]; //кол-во сегментов
    k_razdelov = k_count ;
for (d=1; d<=h; d++) //фор повторов сегментов
    x = 1;// [j] у Mas
    for(j=1; j<=k[i]; j++){ //кол-во элементов в сегменте
       for(m=y; m<=k_razdelov; m++)
          Masiv[m][i] = Mas[i][x]; 
       x++;
       y = k_razdelov ;//переход к след сегменту
       k_razdelov = k_radelov+k_razdelov ;//т.к. переход к след разделу
          }
}
}